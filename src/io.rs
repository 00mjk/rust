//! A module for writing TFRecords, Tensorflow's preferred on-disk data format.
//!
//! See the [tensorflow docs](https://www.tensorflow.org/api_guides/python/python_io#tfrecords-format-details) for details of this format.

extern crate byteorder;

use std::io;
use std::io::prelude::*;
use self::byteorder::{ByteOrder, LittleEndian as LE};
use self::byteorder::WriteBytesExt;

/// A type for writing bytes in the TFRecords format.
#[derive(Debug)]
pub struct RecordWriter<W: Write> {
    writer: W
}

impl<W> RecordWriter<W> where W: Write {
    /// Construct a new RecordWriter which writes to `writer`.
    pub fn new(writer: W) -> Self {
        RecordWriter { writer }
    }

    /// Write a complete TFRecord.
    pub fn write_record(&mut self, bytes: &[u8]) -> io::Result<()> {
        /* A TFRecords file contains a sequence of strings 
        with CRC32C (32-bit CRC using the Castagnoli polynomial) hashes. Each record has the format

        uint64 length
        uint32 masked_crc32_of_length
        byte   data[length]
        uint32 masked_crc32_of_data
        and the records are concatenated together to produce the file. CRCs are described here [1], and the mask of a CRC is
        [1] https://en.wikipedia.org/wiki/Cyclic_redundancy_check
        masked_crc = ((crc >> 15) | (crc << 17)) + 0xa282ead8ul
        */
        let mut len_bytes = vec![];
        len_bytes.write_u64::<byteorder::LittleEndian>(bytes.len() as u64)?;

        let masked_len_crc32c = Self::mask(crc32c(&len_bytes));
        let mut len_crc32c_bytes: Vec<u8> = vec![];
        len_crc32c_bytes.write_u32::<byteorder::LittleEndian>(masked_len_crc32c)?;

        let masked_bytes_crc32c = Self::mask(crc32c(&bytes));
        let mut bytes_crc32_bytes: Vec<u8> = vec![];
        bytes_crc32_bytes.write_u32::<byteorder::LittleEndian>(masked_bytes_crc32c)?;

        self.writer.write(&len_bytes)?;
        self.writer.write(&len_crc32c_bytes)?;
        self.writer.write(bytes)?;
        self.writer.write(&bytes_crc32_bytes)?;
        Ok(())
    }

    fn mask(crc: u32) -> u32 {
        ((crc >> 15) | (crc << 17)).wrapping_add(0xa282ead8u32)
    }
}

// this pure-rust Castagnoli CRC32 algorithm is lifted from 
// rust-snappy (https://github.com/BurntSushi/rust-snappy/blob/master/src/crc32.rs)
// The available crc32c crates don't work on stable.
const CASTAGNOLI_POLY: u32 = 0x82f63b78;

lazy_static! {
    static ref TABLE: [u32; 256] = make_table(CASTAGNOLI_POLY);
    static ref TABLE16: [[u32; 256]; 16] = {
        let mut tab = [[0; 256]; 16];
        tab[0] = make_table(CASTAGNOLI_POLY);
        for i in 0..256 {
            let mut crc = tab[0][i];
            for j in 1..16 {
                crc = (crc >> 8) ^ tab[0][crc as u8 as usize];
                tab[j][i] = crc;
            }
        }
        tab
    };
}
fn make_table(poly: u32) -> [u32; 256] {
    let mut tab = [0; 256];
    for i in 0u32..256u32 {
        let mut crc = i;
        for _ in 0..8 {
            if crc & 1 == 1 {
                crc = (crc >> 1) ^ poly;
            } else {
                crc >>= 1;
            }
        }
        tab[i as usize] = crc;
    }
    tab
}
/// Returns the CRC32 checksum of `buf` using the Castagnoli polynomial.
fn crc32c(mut buf: &[u8]) -> u32 {
    let tab = &*TABLE;
    let tab8 = &*TABLE16;
    let mut crc: u32 = !0;
    while buf.len() >= 8 {
        crc ^= LE::read_u32(&buf[0..4]);
        crc = tab8[0][buf[7] as usize]
            ^ tab8[1][buf[6] as usize]
            ^ tab8[2][buf[5] as usize]
            ^ tab8[3][buf[4] as usize]
            ^ tab8[4][(crc >> 24) as u8 as usize]
            ^ tab8[5][(crc >> 16) as u8 as usize]
            ^ tab8[6][(crc >> 8 ) as u8 as usize]
            ^ tab8[7][(crc      ) as u8 as usize];
        buf = &buf[8..];
    }
    for &b in buf {
        crc = tab[((crc as u8) ^ b) as usize] ^ (crc >> 8);
    }
    !crc
}
////////////////////////

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::File;

    #[test]
    fn writer_identical_to_python() {
        let actual_filename = "test_resources/io/actual.tfrecord";
        // This file was generated by test_resources/io/python_writer.py
        let expected_filename = "test_resources/io/expected.tfrecord";
        {
            let f = ::std::fs::OpenOptions::new()
                .write(true)
                .create(true)   
                .open(actual_filename)
                .unwrap();

            let mut record_writer = RecordWriter::new(::std::io::BufWriter::new(f));
            record_writer.write_record("The Quick Brown Fox".as_bytes()).unwrap();
        }

        let mut af = File::open(actual_filename).unwrap();
        let mut ef = File::open(expected_filename).unwrap();
        let mut actual = vec![0; 0];
        let mut expected = vec![0; 0];
        af.read_to_end(&mut actual).unwrap();
        ef.read_to_end(&mut expected).unwrap();

        assert_eq!(actual, expected);
    }

}